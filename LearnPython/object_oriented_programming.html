<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Learn Python</title>
    <link rel="stylesheet" href="assets/css/bootstrap.css">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-nav-demo"
                    aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="index.html" class="navbar-brand">Learn Python</a>
        </div>
        <div class="collapse navbar-collapse" id="bs-nav-demo">
            <ul class="nav navbar-nav">
                <li><a href="index.html">Home</a></li>
                <li><a href="objectives.html">Objectives</a></li>
                <li><a href="mailto: ngfinch@asu.edu">Contact</a></li>
            </ul>
            <!--<ul class="nav navbar-nav navbar-right">
                <li><a href="#">Sign Up</a></li>
                <li><a href="#">Login</a></li>
            </ul>-->
        </div>
    </div>
</nav>
<div class="container" style="padding-top: 50px">
    <div class="col-md-12 grey">
            <div class="content">
                <h3>Overview of OOP Terminology</h3>
                <p><code>Class</code> − A user-defined prototype for an object that defines a set of attributes that characterize any object of the class. The attributes are data members (class variables and instance variables) and methods, accessed via dot notation.
                <p><code>Class variable</code> − A variable that is shared by all instances of a class. Class variables are defined within a class but outside any of the class's methods. Class variables are not used as frequently as instance variables are.
                <p><code>Data member</code> − A class variable or instance variable that holds data associated with a class and its objects.
                <p><code>Function overloading</code> − The assignment of more than one behavior to a particular function. The operation performed varies by the types of objects or arguments involved.
                <p><code>Instance variable</code> − A variable that is defined inside a method and belongs only to the current instance of a class.
                <p><code>Inheritance</code> − The transfer of the characteristics of a class to other classes that are derived from it.
                <p><code>Instance</code> − An individual object of a certain class. An object obj that belongs to a class Circle, for example, is an instance of the class Circle.
                <p><code>Instantiation</code> − The creation of an instance of a class.
                <p><code>Method</code> − A special kind of function that is defined in a class definition.
                <p><code>Object</code> − A unique instance of a data structure that's defined by its class. An object comprises both data members (class variables and instance variables) and methods.
                <p><code>Operator overloading</code> − The assignment of more than one function to a particular operator.
            </div>
        </div>

    <div class="col-md-12 ">
            <div class="content">
                <h3>Creating Classes</h3>
                <p>The class statement creates a new class definition. The name of the class immediately follows the keyword class followed by a colon as follows −

                <pre><code>
                class ClassName:
                    'Optional class documentation string'
                    class_suite
                </code></pre>

                <p>The class has a documentation string, which can be accessed via ClassName.__doc__.

                <p>The class_suite consists of all the component statements defining class members, data attributes and functions.

                <h3>Example</h3>
                <p>Following is the example of a simple Python class −

                    <pre><code>
                class Employee:
                    'Common base class for all employees'
                    empCount = 0

                    def __init__(self, name, salary):
                        self.name = name
                        self.salary = salary
                        Employee.empCount += 1

                    def displayCount(self):
                        print "Total Employee %d" % Employee.empCount

                    def displayEmployee(self):
                        print "Name : ", self.name,  ", Salary: ", self.salary
                    </code></pre>
                <p>The variable empCount is a class variable whose value is shared among all instances of a this class. This can be accessed as Employee.empCount from inside the class or outside the class.

                <p>The first method <code>__init__()</code> is a special method, which is called class constructor or initialization method that Python calls when you create a new instance of this class.

                <p>You declare other class methods like normal functions with the exception that the first argument to each method is self. Python adds the self argument to the list for you; you do not need to include it when you call the methods.
            </div>
        </div>

    <div class="col-md-12 grey">
        <div class="content">
            <h3>Creating Instance Objects</h3>
            <p>To create instances of a class, you call the class using class name and pass in whatever arguments its
                <code>__init__</code> method accepts.
            <pre><code>
            "This would create first object of Employee class"
            emp1 = Employee("Zara", 2000)
            "This would create second object of Employee class"
            emp2 = Employee("Manni", 5000)
            </code></pre>
        </div>
    </div>

    <div class="col-md-12">
        <div class="content">
            <h3>Accessing Attributes</h3>
            <p>You access the object's attributes using the dot operator with object. Class variable would be accessed using class name as follows −
            <pre><code>
            emp1.displayEmployee()
            emp2.displayEmployee()
            print "Total Employee %d" % Employee.empCount
            </code></pre>
            Now, putting all the concepts together −

            <pre><code>
            class Employee:
                'Common base class for all employees'
                empCount = 0

            def __init__(self, name, salary):
                self.name = name
                self.salary = salary
                Employee.empCount += 1

            def displayCount(self):
                print "Total Employee %d" % Employee.empCount

            def displayEmployee(self):
                print "Name : ", self.name,  ", Salary: ", self.salary

            "This would create first object of Employee class"
            emp1 = Employee("Zara", 2000)
            "This would create second object of Employee class"
            emp2 = Employee("Manni", 5000)
            emp1.displayEmployee()
            emp2.displayEmployee()
            print "Total Employee %d" % Employee.empCount
                </code></pre>

            <p>When the above code is executed, it produces the following result −

                <pre><code>
            Name :  Zara ,Salary:  2000
            Name :  Manni ,Salary:  5000
            Total Employee 2
            </code></pre>

            <p>You can add, remove, or modify attributes of classes and objects at any time −
                <pre><code>
            emp1.age = 7  # Add an 'age' attribute.
            emp1.age = 8  # Modify 'age' attribute.
            del emp1.age  # Delete 'age' attribute.
            </code></pre>

            <p>Instead of using the normal statements to access attributes, you can use the following functions −
                The <code>getattr(obj, name[, default])</code> − to access the attribute of object.

                The <code>hasattr(obj,name)</code> − to check if an attribute exists or not.

                The <code>setattr(obj,name,value)</code> − to set an attribute. If attribute does not exist, then it would be created.

                The <code>delattr(obj, name)</code> − to delete an attribute.
            <pre><code>
            hasattr(emp1, 'age')    # Returns true if 'age' attribute exists
            getattr(emp1, 'age')    # Returns value of 'age' attribute
            setattr(emp1, 'age', 8) # Set attribute 'age' at 8
            delattr(empl, 'age')    # Delete attribute 'age'
        </code></pre>
        </div>
    </div>

    <div class="col-md-12 grey">
        <div class="content">
            <h3>Built-In Class Attributes</h3>
            <p>Every Python class keeps following built-in attributes and they can be accessed using dot operator like any other attribute −</p>
            <p><code>__dict__</code> − Dictionary containing the class's namespace.
            <p><code>__doc__</code> − Class documentation string or none, if undefined.
            <p><code>__name__</code> − Class name.
            <p><code>__module__</code> − Module name in which the class is defined. This attribute is "__main__" in interactive mode.
            <p><code>__bases__</code> − A possibly empty tuple containing the base classes, in the order of their occurrence in the base class list.
            <p>For the above class let us try to access all these attributes −
            <pre><code>
            class Employee:
               'Common base class for all employees'
               empCount = 0

               def __init__(self, name, salary):
                  self.name = name
                  self.salary = salary
                  Employee.empCount += 1

               def displayCount(self):
                 print "Total Employee %d" % Employee.empCount

               def displayEmployee(self):
                  print "Name : ", self.name,  ", Salary: ", self.salary

            print "Employee.__doc__:", Employee.__doc__
            print "Employee.__name__:", Employee.__name__
            print "Employee.__module__:", Employee.__module__
            print "Employee.__bases__:", Employee.__bases__
            print "Employee.__dict__:", Employee.__dict__
            </code></pre>
            <p>When the above code is executed, it produces the following result −

            <pre><code>
            Employee.__doc__: Common base class for all employees
            Employee.__name__: Employee
            Employee.__module__: __main__
            Employee.__bases__: ()
            Employee.__dict__: {'__module__': '__main__', 'displayCount':
            &lt;function displayCount at 0xb7c84994&gt;, 'empCount': 2,
            'displayEmployee': &lt;function displayEmployee at 0xb7c8441c&gt;,
            '__doc__': 'Common base class for all employees',
            '__init__': &lt;function __init__ at 0xb7c846bc&gt;}
            </code></pre>
        </div>
    </div>

    <div class="col-md-12">
        <div class="content">
            <h3>Destroying Objects (Garbage Collection)</h3>
            <p>Python deletes unneeded objects (built-in types or class instances) automatically to free the memory
                space. The process by which Python periodically reclaims blocks of memory that no longer are in use is
                termed Garbage Collection.

            <p></p>Python's garbage collector runs during program execution and is triggered when an object's reference
            count reaches zero. An object's reference count changes as the number of aliases that point to it changes.

            <p>An object's reference count increases when it is assigned a new name or placed in a container (list,
                tuple, or dictionary). The object's reference count decreases when it's deleted with del, its reference
                is reassigned, or its reference goes out of scope. When an object's reference count reaches zero, Python
                collects it automatically.
            <pre><code>
            a = 40      # Create object <40>
            b = a       # Increase ref. count  of <40>
            c = [b]     # Increase ref. count  of <40>

            del a       # Decrease ref. count  of <40>
            b = 100     # Decrease ref. count  of <40>
            c[0] = -1   # Decrease ref. count  of <40>
            </code></pre>
            <p>You normally will not notice when the garbage collector destroys an orphaned instance and reclaims its space. But a class can implement the special method __del__(), called a destructor, that is invoked when the instance is about to be destroyed. This method might be used to clean up any non memory resources used by an instance.

            <h3>Example</h3>
            <p>This <code>__del__()</code> destructor prints the class name of an instance that is about to be destroyed −
            <pre><code>
            class Point:
               def __init__( self, x=0, y=0):
                  self.x = x
                  self.y = y
               def __del__(self):
                  class_name = self.__class__.__name__
                  print class_name, "destroyed"

            pt1 = Point()
            pt2 = pt1
            pt3 = pt1
            print id(pt1), id(pt2), id(pt3) # prints the ids of the obejcts
            del pt1
            del pt2
            del pt3
            </code></pre>
            <p>When the above code is executed, it produces following result −
            <pre><code>
            3083401324 3083401324 3083401324
            Point destroyed
            </code></pre>
            <p><b>Note</b> − Ideally, you should define your classes in separate file, then you should import them in your main program file using import statement.
        </div>
    </div>

    <div class="col-md-12 grey">
        <div class="content">
            <h3>Class Inheritance</h3>
            <p>Instead of starting from scratch, you can create a class by deriving it from a preexisting class by listing the parent class in parentheses after the new class name.

            <p>The child class inherits the attributes of its parent class, and you can use those attributes as if they were defined in the child class. A child class can also override data members and methods from the parent.

            <h3>Syntax</h3>
            <p>Derived classes are declared much like their parent class; however, a list of base classes to inherit from is given after the class name −
            <pre><code>
            class SubClassName (ParentClass1[, ParentClass2, ...]):
               'Optional class documentation string'
               class_suite
            </code></pre>
            <h3>Example</h3>
            <pre><code>
            class Parent:        # define parent class
               parentAttr = 100
               def __init__(self):
                  print "Calling parent constructor"

               def parentMethod(self):
                  print 'Calling parent method'

               def setAttr(self, attr):
                  Parent.parentAttr = attr

               def getAttr(self):
                  print "Parent attribute :", Parent.parentAttr

            class Child(Parent): # define child class
               def __init__(self):
                  print "Calling child constructor"

               def childMethod(self):
                  print 'Calling child method'

            c = Child()          # instance of child
            c.childMethod()      # child calls its method
            c.parentMethod()     # calls parent's method
            c.setAttr(200)       # again call parent's method
            c.getAttr()          # again call parent's method

            </code></pre>
            <p>When the above code is executed, it produces the following result −
            <pre><code>
            Calling child constructor
            Calling child method
            Calling parent method
            Parent attribute : 200
        </code></pre>
            <p>Similar way, you can drive a class from multiple parent classes as follows −
            <pre><code>
            class A:        # define your class A
            .....

            class B:         # define your class B
            .....

            class C(A, B):   # subclass of A and B
            .....
        </code></pre>
            <p>You can use issubclass() or isinstance() functions to check a relationships of two classes and instances.

            <p>The <code>issubclass(sub, sup)</code> boolean function returns true if the given subclass sub is indeed a subclass of the superclass sup.

            <p>The <code>isinstance(obj, Class)</code> boolean function returns true if obj is an instance of class Class or is an instance of a subclass of Class
        </div>
    </div>
    <iframe src="https://www.tutorialspoint.com/execute_python_online.php" id="tryPythonIframe" style="
    height: 504px;
"></iframe>
</div>
<script src="assets/js/jquery-2.1.4.js"></script>
<script src="assets/js/bootstrap.js"></script>

<div id="ext_session_alive_reload_prompt" style="display: none;">
    <div>
        <div>To Keep Your Session Active<br>page will reload in <span id="session_live_reloader_countdown">30</span>
            seconds<br><a id="ext_session_alive_reload_rule_id"
                          href="chrome-extension://lhobbakbeomfcgjallalccfhfcgleinm/settings.html"
                          target="_rule_settings">Edit Rule<br></a></div>
        <div>
            <button type="button" id="ext_session_alive_reload_cancel">Wait 1 minute</button>
        </div>
    </div>
</div>
</body>
</html>